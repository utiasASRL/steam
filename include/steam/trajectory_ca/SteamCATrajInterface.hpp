//////////////////////////////////////////////////////////////////////////////////////////////
/// \file SteamCATrajInterface.hpp
///
/// \author Tim Tang, ASRL
//////////////////////////////////////////////////////////////////////////////////////////////

#ifndef STEAM_CA_TRAJECTORY_INTERFACE_HPP
#define STEAM_CA_TRAJECTORY_INTERFACE_HPP

#include <steam/trajectory_ca/SteamCATrajVar.hpp>
#include <steam/trajectory/SteamTrajInterfaceTemplate.hpp>

namespace steam {
namespace se3 {

//////////////////////////////////////////////////////////////////////////////////////////////
/// \brief The trajectory class wraps a set of state variables to provide an interface
///        that allows for continuous-time pose interpolation.
//////////////////////////////////////////////////////////////////////////////////////////////
class SteamCATrajInterface : public SteamTrajInterfaceTemplate<SteamCATrajVar>
{
 public:

  using SteamTrajInterfaceTemplate<SteamCATrajVar>::SteamTrajInterfaceTemplate;
  using SteamTrajInterfaceTemplate<SteamCATrajVar>::add;

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Add a new knot
  //////////////////////////////////////////////////////////////////////////////////////////////
  void add(const steam::Time& time, const se3::TransformEvaluator::Ptr& T_k0,
           const VectorSpaceStateVar::Ptr& velocity,
           const VectorSpaceStateVar::Ptr& acceleration) override;

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Get evaluator
  //////////////////////////////////////////////////////////////////////////////////////////////
  TransformEvaluator::ConstPtr getInterpPoseEval(const steam::Time& time) const override;

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Get velocity evaluator
  //////////////////////////////////////////////////////////////////////////////////////////////
  Eigen::VectorXd getVelocity(const steam::Time& time) override;

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Add a unary acceleration prior factor at a knot time. Note that only a single acceleration
  ///        prior should exist on a trajectory, adding a second will overwrite the first.
  //////////////////////////////////////////////////////////////////////////////////////////////
  void addAccelerationPrior(const steam::Time& time, const Eigen::Matrix<double,6,1>& acceleration,
    const Eigen::Matrix<double,6,6>& cov) override;

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Get binary cost terms associated with the prior for active parts of the trajectory
  //////////////////////////////////////////////////////////////////////////////////////////////
  void appendPriorCostTerms(const ParallelizedCostTermCollection::Ptr& costTerms) const;

 private:

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Acceleration prior
  //////////////////////////////////////////////////////////////////////////////////////////////
  steam::WeightedLeastSqCostTerm<6,6>::Ptr accelerationPriorFactor_;

};

} // se3
} // steam

#endif // STEAM_CA_TRAJECTORY_INTERFACE_HPP
